using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Weekend16
{
    internal class Program
    {

        class Son
        {
            public string jumin;    // 멤버 필드
            public string address;
            public int age;

        }

        struct Student  //구조체는 값타입으로 전달이 됨
        {
            public string name;
            public int age;
            public int grade;
        }



        static void ChangeVlaue(Son Value)  //메소드 손이라는게 동적메모리에 저장이 되었고, 스택이라는 영역에 손이라는 변수가 만들어지고
                                            //메모리 1000번지에 만들어졌다고 하면 1000이라는 주소값이 스택에 저장됨
                                            // 체인지 밸류라는 함수를 호출했을 때, 매개변수로 전달된 거 밸류라는 변수가 만들어지고
                                            //손이 가지고 있는 주소값이 전달된것이다
                                            //주소값이 같기 때문에 그걸 통해서 동적메모리 멤버변수에 접근을 했고 그 값을 바꾼것이다
                                            //클래스형은 무조건 참조타입 주소값에 따라 컨트롤이 된다
        {
            Value.age = 20;
            Value.address = "서울";
            Value.jumin = "234";
        }

       static void ChangeInt(int value)
        {
            value = 1000;   //1000을 넣는다고 해서 저장공간이 컨트롤되는 게 아님
        }

        static void ChangeST(Student value)
        {
            value.age = 20;
            value.grade = 1;
            value.name = "원숭이";
        }


        static void Main(string[] args)
        {
            //오브젝트은 모든것의 상위타입이라 힙에 만들어진다 하지만 값타입임

            

            Son son = new Son();

            son.jumin = "1234";
            son.address = "런던";
            son.age = 17;

            int a;
            a = 20;


            Console.WriteLine
                ($"son.jumin = {son.jumin}, son.address = {son.address}, son.age = {son.age}");

            ChangeVlaue(son);   //손이라는 밸류 전달
            //함수의 인자값으로 전달된 손이라는 참조형 변수가 전달

            Console.WriteLine
                ($"son.jumin = {son.jumin}, son.address = {son.address}, son.age = {son.age}"); //바뀐 상태로 나온다
            //클래스형 데이터 타입은 무조건 참조타입으로 전달하게 되어있음 


            Console.WriteLine(a);
            ChangeInt(a);
            Console.WriteLine(a);


            Student st;

            st.age = 10;
            st.grade = 3;
            st.name = "나은";

            Console.WriteLine($"before st.age = {st.age}, st.grade = {st.grade}, st.name = {st.name}");
            ChangeST(st);
            Console.WriteLine($"after st.age = {st.age}, st.grade = {st.grade}, st.name = {st.name}");


            //st변수는 스택에 만들어지고 에이지라는 멤ㅁ버 그레이드 네임이라는 멤버가 있음
            //함수에서st를 전달했는데 그 때 전달되는게 매개변수 밸류라는 공간이 만들어진다. (스택)
            //st가 전달됐으니까 그 값이 그대로 똑같이 복사가 된다
            //값이 전달된거지 ( 주소값이 전달된게 아니고) st가 가지고 있는 값이 value에 전달이 된거라서
            //함수 안에서 만든 밸류 안의 값이 변하는거잖아요
            //그럼 실제로 메인에 있는st변수는 그대로 자기 값을 가지고 있기 때문에 영향이 없는거고
            //클래스형처럼 주소값이 전달되서 외부 인자가 영향을 주는게 아니다. 그런 방식은 참조타입이라고 한다
            //c나c++이라고 하면 참조형은 포인터 변수를 말하는거고, 값타입은 일반변수를 말하는건데 스택에 저장되는거
            //값타입으로 만드는건 구조체 기본데이터타입 열거형 이렇게 값타입으로 만들 수 있다 그 외에는 참조타입으로 작동한다
            //근데 약간 애매한게 스트링형 함수를 받아서 스트링 변수를 받고 문자를 넣으면..
            //문자형을 출력을 하면 / 출력 / 함수 / 출력  => 스트링타입도 안바뀜 ( 값타입처럼)
            //참조타입이라고 되어있긴 한데 실제로 넘겨보면 값타입처럼 작동을 한다.
        }




        /*c#은 객체지향언어이다 
         객체가 무엇인가? 

        이거때문에 과학이 발전했다고 합니다
        인간이 아주 잘한다고 합니다 (본능적으로)
        주변에도 이런 걸 많이 볼 수 있다
        지도를 생각해보자
        지도는..지구에서 위치정보 / 지형정보만 취해서 만든 것이다
        지구라는 대상은 많은 정보를 가지고 있다
        그 정보 : 지구 (대상객체)중에서 필요한 정보만 취해 단순화 시키는 것 (추상화)
        추상화의 결과물들을 주변에서 많이 볼 수 있다
        지하철 노선도는 지하철의 노선을 단순화시킨 것 우리가 필요한 역 정보만 가져온 것
        단순화시켜 점과 선으로 만든게 지하철노선도이다.
        우리가 필요한건 지형정보가 아니라 역 정보만 필요하기 때문에
        필요한 정보만 뺴내 만들었다 
        문제 안에 많은 정보들이 들어있는데 문제를 풀기 위한 것만 추려내는 것 ( 추상화 )
        다른 정보들은 불필요한데 오히려 그 정보들 때문에 혼란이 가중된다
        어떤 대상이 가지고 있는 정보(대상객체) 중에서 필요한 정보를 취하는 것, 단순화 시키는 능력을 추상화라고 한다
        단어들을 일반화하는 것도 추상화이다 ( 사슴이 다 똑같지 않음. 호랑이도 생김새가 똑같지 않음)
        그러나 사슴을 단순화시켜서 범주 안에 들으면 다 사슴이라고 일반화시킨다

        손흥민이라는 대상이 있는데 손흥민을 동사무소에서 취하는 정보, 축구게임에서 취하는 정보는 다르다
        이러한 정보를 컴퓨터에 넣으려고 한다면 string 주민번호, int 나이 이런식으로 묶을 수 있고
        그것들은 클래스로 묶어준다

        class 클래스명 {
            데이터
        }

         class Son {
            public string 주민번호  //필드라고 한다 (데이터를 담당하고 있는 부분)
            public int 나이       
        }

        이걸 캡슐화 했다고 한다. 캡슐화를 한다는 건 클래스형 데이터 타입을 만드는 것이다
        클래스명이 데이터 타입이 된 것이다. 데이터타입을 만들었으니까 데이터타입의 변수를 만들 수 있음
        Son 함수를 가지고 son이라는 변수를 만들었다
        그럼 그 변수 안에 있는 멤버필드를 접근할 때 . 을 사용하면 된다
        son.주민번호 ="1234";
        son.나이 = 17;

        근데 이거 에러나는데, c#에서는 클래스형 데이터 타입에서는 이런 형태의 데이터를 만들 수 없다
        클래스형 데이터타입을 만드려면 new를 해줘야 함

        그래서 Son son = new Son();

        c#에는 값타입과 참조타입 두 종류로 나눠지게 되는데 

        약간 이런식으로 int a ; 이렇게는 안됨

        값타입으로 만들어지는건 기본데이터 타입, 구조체, 열거형을 만들 수 있고
        참조타입으로는 클래스형 데이터타입

        c#에서는 무조건 new연산자로 할당해줘야함

        값타입은 스택에 메모리가 만들어지고
        참조타입은 동적메모리 힙에 저장이 된다
        스택 영역에 손이라는 클래스타입의 변수가 스택에 저장이 되고 클래스
        뉴를 통해서 힙에 손이라는 변수가 만들어지고, 동적메모리공간에 만들어진 손이라는 변수의 주솟값을 손이라는 변수가 스택에 가지고 있음
        참조형은 무조건 동적메모리공간 힙에 만들어지고 주소값이 스택에 물어진 형태가 된다

        인트 에이는 20이면 스택에 바로 20이라는 값이 들어간다
        하지만 클래스형은 동적메모리에 만들어지고 스택영역에 참조형변수가 만들어지고
        스택에 만들어진 공간에 값을 넣는 것을 값타입이라고 한다
        바로 만들어진 공간에 값을 넣으면 값
        참조타입은 동적메모리공간에 저장이 되고 주소값을 스택에 저장한다

        동적메모리공간에 뉴 손이라는 명령어를 통해 동적메모리공간에 데이터가 저장되고
        뉴 연산자가 손이라는 메모리 공간을 할당하고 스택이라는 공간에 손이라는 참조형 변수가 만들어짐
        동적메모리공간에 ㅎㄹ당될 때 2000번지라면 그게 스택에 참조형 변수로 저장됨
        클래스명의 참조형변수가 주소값 가지고 있음


        a변수는 스택이라는 영역에 a 변수가 만들어지는데 그건 값이 바로 들어가면
        스택에 공간이 만들어지고 그건 값타입이라고 함
        값이 들어가는 공간은 동적메모리공간에 저장되고 주소값을 스택에 저장하는걸 참조타입

        씨나 씨쁠쁠에서는 포인터형 변수가 되는 것이다 그걸 참조타입이라고 씨샵에서는 하는거고
        씨쁠쁠은 스택에도 만들 수 있고 힙에도 만들 수 있지만 씨샵은 무조건 동적으로 만들게 되어있음
        클래스형 데이터형 타입으로 변수를 만들 때는 new 연산자로 만들어 값을 채워줘야 한다

        값타입 : 기본타입, 구조체, 열거형 (스트링 제외)
        참조타입 : 클래스형 데이터 타입 스트링 클래스 어레이


        */






    }
    }

