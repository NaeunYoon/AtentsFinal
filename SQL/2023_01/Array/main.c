#include <stdio.h>
int main() {

	/*
	자료구조 : 데이터를 저장하는 방식 (스택 큐 링크드리스트 트리..)
	배열 : 데이터를 순차적으로 저장할 때 사용
	*/
	int array[10];
	//공간이 뭉탱이로 만들어지고 10개가 할당된다 40바이트 (인접해서 만들어짐) : 그걸 내가 4바이트씩 10개로 쪼개서 쓴다
	//배열식을 사용해 데이터를 쉽게 접근할 수 있다 (임의접근)
	//그러나 한 번 사이즈를 저장하면 이 사이즈 이상을 저장할 수 없다 fixed
	//가변적인 데이터를 저장 할 때에는 용이하지 않다
	//갯수가 일정하거나 이하일 때 사용하기 용이하다
	//삽입과 삭제가 용이하지 않다 
	//숫자가 11개 저장되어 있는데 만약 저장되어있는 수 중간에 삽입하고 싶다면 삽입 할 위치의 다음 숫자부터 하나씩 미뤄야 한다
	//중간 값을 삭제하고 싶다면 삭제할 값의 다음 값을 다 앞으로 땡겨야 한다

	//리스트 : 데이터 저장 공간 자체를 따로 하나씩 만드는 것이다
	//그리고 앞쪽 노드와 뒷쪽 노드를 연결한다 ( 앞쪽 노드가 뒷쪽 노드의 주소값을 가지고 있다
	//데이터가 순차적으로 저장할 수 있지만 저장 공간 자체는 물리적으로 떨어져 있다
	//물리적으로 떨어져 있는 것을 논리적으로 연결한 것이다 linkedList
	//필요할 때마다 만들고 연결을 한 것이다, 삽임과 삭제가 용이하다
	//추가하는걸 uphand 삽입을 insert 삭제를 remove 라고 한다
	//맨 앞에 있는 노드를 헤드노드 맨 뒤에 있는 걸 테일이라고 한다
	//insert new 함수가 있다 ( 헤드노드의 주소값은 항상 어딘가에 저장을 해야한다)
	//배열은 임의접근이 가능하지만, 링크드 리스트는 머리부터 꼬리까지 순차적으로 찾아야 한다.
	//리스트 하나하나를 만들 때 동적으로 만든다 ( 동적 메모리를 할당받을 때 오버헤드가 있다)
	//동적메모리공간을 만들 때 os에게 요청하고 쓰지 않는 공간을 찾아서 관리대장을 뒤진 뒤 적절한 위치의 주소값을 리턴한다
	//이 과정이 오버헤드가 있음 따라서 동적메모리 공간 보다는 배열이 효율적이다
	//동적 메모리 공간을 만들 때 마다 비용이 든다
	// 
	//데이터를 순차적으로 저장할 때 배열과 링크드 리스트 사이에서 고민하는 것이다
	//회원관리를 하는 프로그램 : 기획자가 3000명 고정이라고 하면 배열을 쓰는 것이 유일하다
								 //명수가 불명확하면 리스트를 쓴다
	//스타크래프트 유닛은 최대 200개 : 유닛을 관리하는 것을 배열로 만들었다 라고 할 수 있다 ( 유닛의 갯수를 한정함)



	return 0;
}